import fs from "node:fs";
import path from "node:path";

import archiver from "archiver";
import { Writable } from "stream";
import type { Test, TestSection, Topic, Question, TopicCourse, PassRule } from "@shared/schema";

interface ExportData {
  test: Test;
  sections: (TestSection & { topic: Topic; questions: Question[]; courses: TopicCourse[] })[];
}



function buildTestJson(data: ExportData): string {
  const totalQuestions = data.sections.reduce((sum, s) => sum + s.drawCount, 0);
  const overallPassRule = data.test.overallPassRuleJson as PassRule;
  const passPercent = overallPassRule.type === "percent" 
    ? overallPassRule.value 
    : totalQuestions > 0 ? Math.round((overallPassRule.value / totalQuestions) * 100) : 80;

  const test = {
    id: data.test.id,
    title: data.test.title,
    description: data.test.description,
    overallPassRule: overallPassRule,
    webhookUrl: data.test.webhookUrl,
    testFeedback: data.test.feedback || null,
    timeLimitMinutes: data.test.timeLimitMinutes || null,
    maxAttempts: data.test.maxAttempts || null,
    showCorrectAnswers: data.test.showCorrectAnswers || false,
    startPageContent: data.test.startPageContent || null,
    passPercent: passPercent,
    totalQuestions: totalQuestions,
    sections: data.sections.map((s) => ({
      topicId: s.topic.id,
      topicName: s.topic.name,
      drawCount: s.drawCount,
      topicPassRule: s.topicPassRuleJson as PassRule | null,
      topicFeedback: s.topic.feedback || null,
      recommendedCourses: s.courses.map((c) => ({ title: c.title, url: c.url })),
      questions: s.questions.map((q) => ({
        id: q.id,
        type: q.type,
        prompt: q.prompt,
        data: q.dataJson,
        correct: q.correctJson,
        points: q.points || 1,
        mediaUrl: q.mediaUrl || null,
        mediaType: q.mediaType || null,
        feedback: q.feedback || null,
        feedbackMode: q.feedbackMode || "general",
        feedbackCorrect: q.feedbackCorrect || null,
        feedbackIncorrect: q.feedbackIncorrect || null,
      })),
    })),
  };

  return JSON.stringify(test, null, 2);
}

function buildManifest(test: Test, data: ExportData): string {
  const id = `test_${test.id}`;
  const overallPassRule = test.overallPassRuleJson as PassRule;
  const totalQuestions = data.sections.reduce((sum, s) => sum + s.drawCount, 0);
  const overallThreshold = overallPassRule.type === "percent" 
    ? (overallPassRule.value / 100).toFixed(2) 
    : totalQuestions > 0 ? (overallPassRule.value / totalQuestions).toFixed(2) : "0.8";
  
  const objectives = data.sections.map((s) => {
    const topicPassRule = s.topicPassRuleJson as PassRule | null;
    let threshold = "0.5";
    if (topicPassRule) {
      threshold = topicPassRule.type === "percent" 
        ? (topicPassRule.value / 100).toFixed(2) 
        : (topicPassRule.value / s.drawCount).toFixed(2);
    }
    return `
        <imsss:objective objectiveID="obj_topic_${s.topic.id}">
          <imsss:minNormalizedMeasure>${threshold}</imsss:minNormalizedMeasure>
        </imsss:objective>`;
  }).join("");

  return `<?xml version="1.0" encoding="UTF-8"?>
<manifest identifier="${id}" version="1.0"
  xmlns="http://www.imsglobal.org/xsd/imscp_v1p1"
  xmlns:adlcp="http://www.adlnet.org/xsd/adlcp_v1p3"
  xmlns:adlseq="http://www.adlnet.org/xsd/adlseq_v1p3"
  xmlns:adlnav="http://www.adlnet.org/xsd/adlnav_v1p3"
  xmlns:imsss="http://www.imsglobal.org/xsd/imsss"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.imsglobal.org/xsd/imscp_v1p1 imscp_v1p1.xsd
    http://www.adlnet.org/xsd/adlcp_v1p3 adlcp_v1p3.xsd
    http://www.adlnet.org/xsd/adlseq_v1p3 adlseq_v1p3.xsd
    http://www.adlnet.org/xsd/adlnav_v1p3 adlnav_v1p3.xsd
    http://www.imsglobal.org/xsd/imsss imsss_v1p0.xsd">

  <metadata>
    <schema>ADL SCORM</schema>
    <schemaversion>2004 4th Edition</schemaversion>
    <adlcp:location>metadata.xml</adlcp:location>
  </metadata>

  <organizations default="org_${id}">
    <organization identifier="org_${id}" structure="hierarchical">
      <title>${escapeXml(test.title)}</title>
      <item identifier="item_${id}" identifierref="res_${id}">
        <title>${escapeXml(test.title)}</title>
        <imsss:sequencing>
          <imsss:controlMode choice="true" flow="true" />
          <imsss:deliveryControls completionSetByContent="true" objectiveSetByContent="true" />
          <imsss:objectives>
            <imsss:primaryObjective objectiveID="primary_obj" satisfiedByMeasure="true">
              <imsss:minNormalizedMeasure>${overallThreshold}</imsss:minNormalizedMeasure>
            </imsss:primaryObjective>${objectives}
          </imsss:objectives>
        </imsss:sequencing>
        <adlnav:presentation>
          <adlnav:navigationInterface>
            <adlnav:hideLMSUI>continue</adlnav:hideLMSUI>
            <adlnav:hideLMSUI>previous</adlnav:hideLMSUI>
            <adlnav:hideLMSUI>abandon</adlnav:hideLMSUI>
            <adlnav:hideLMSUI>exit</adlnav:hideLMSUI>
          </adlnav:navigationInterface>
        </adlnav:presentation>
      </item>
    </organization>
  </organizations>

  <resources>
    <resource identifier="res_${id}" type="webcontent" adlcp:scormType="sco" href="index.html">
      <file href="index.html"/>
      <file href="styles.css"/>
      <file href="runtime.js"/>
      <file href="app.js"/>
    </resource>
  </resources>
</manifest>`;
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

function buildMetadataXml(test: Test): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<lom xmlns="http://ltsc.ieee.org/xsd/LOM"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://ltsc.ieee.org/xsd/LOM lomStrict.xsd">
  <general>
    <identifier>
      <catalog>test</catalog>
      <entry>${test.id}</entry>
    </identifier>
    <title>
      <string language="en">${escapeXml(test.title)}</string>
    </title>
    <description>
      <string language="en">${escapeXml(test.description || "Assessment test")}</string>
    </description>
    <language>en</language>
  </general>
  <lifeCycle>
    <version>
      <string language="en">1.0</string>
    </version>
    <status>
      <source>LOMv1.0</source>
      <value>final</value>
    </status>
  </lifeCycle>
  <technical>
    <format>text/html</format>
  </technical>
  <educational>
    <interactivityType>
      <source>LOMv1.0</source>
      <value>active</value>
    </interactivityType>
    <learningResourceType>
      <source>LOMv1.0</source>
      <value>exercise</value>
    </learningResourceType>
  </educational>
</lom>`;
}



export function buildAppJs(testJson: string): string {
  return `
// Embedded test data
var TEST_DATA = ${testJson};

// App state
var state = {
  phase: 'start',
  currentIndex: 0,
  answers: {},
  variant: null,
  flatQuestions: [],
  shuffleMappings: {},
  timerInterval: null,
  remainingSeconds: null,
  timeExpired: false,
  submitted: false,
  answerConfirmed: false,
  feedbackShown: false
};
var scormFinished = false;

// Initialize
window.onload = function() {
  SCORM.init();
  window.addEventListener('beforeunload', function() {
    try { SCORM.commit(); } catch (e) {}
    try { SCORM.terminate(); } catch (e) {}
  });
  bindMatchingDnDOnce();
  bindRankingDnDOnce();
  generateVariant();
  render();
  window.addEventListener('resize', function(){ syncMatchingHeights(); });
};

var __matchHeightRAF = 0;
function syncMatchingHeights() {
  try {
    if (__matchHeightRAF) cancelAnimationFrame(__matchHeightRAF);
  } catch (e) {}

  __matchHeightRAF = requestAnimationFrame(function() {
    var roots = document.querySelectorAll('.matching-board');
    for (var i = 0; i < roots.length; i++) {
      var root = roots[i];
      if (!root || !root.style) continue;

      // reset to auto for measurement
      root.style.setProperty('--matchRowH', 'auto');

      // measure after next frame so layout is updated
      (function(r) {
        requestAnimationFrame(function() {
          var nodes = r.querySelectorAll('.match-tile, .match-empty');
          var maxH = 0;
          for (var j = 0; j < nodes.length; j++) {
            var h = nodes[j].offsetHeight || 0;
            if (h > maxH) maxH = h;
          }
          if (maxH < 44) maxH = 56; // safety
          r.style.setProperty('--matchRowH', String(maxH) + 'px');
        });
      })(root);
    }
  });
}

var __matchDndBound = false;

function bindMatchingDnDOnce() {
  if (__matchDndBound) return;
  __matchDndBound = true;

  function closestByClass(node, cls) {
    var el = node;
    while (el && el !== document) {
      if (el.classList && el.classList.contains(cls)) return el;
      el = el.parentNode;
    }
    return null;
  }

    var __matchOverEl = null;

  function clearMatchOver() {
    if (__matchOverEl) __matchOverEl.classList.remove('is-over');
    __matchOverEl = null;
  }

  function setMatchOver(el) {
    if (__matchOverEl && __matchOverEl !== el) __matchOverEl.classList.remove('is-over');
    __matchOverEl = el;
    if (__matchOverEl) __matchOverEl.classList.add('is-over');
  }

  function parsePayloadFromEvent(e) {
    var raw = '';
    try { raw = e.dataTransfer.getData('application/json'); } catch (err) {}
    if (!raw) {
      try { raw = e.dataTransfer.getData('text/plain'); } catch (err2) {}
    }
    if (!raw) return null;

    // JSON first
    try {
      var obj = JSON.parse(raw);
      if (obj && obj.qid) return obj;
    } catch (e1) {}

    // fallback: qid|leftIdx|from|poolIndex|rightIdx
    var parts = String(raw).split('|');
    if (parts.length < 2) return null;

    var qid = parts[0];
    var leftIdx = parseInt(parts[1], 10);
    if (!qid || Number.isNaN(leftIdx)) return null;

    var payload = { qid: qid, leftIdx: leftIdx, from: parts[2] || 'pool' };
    if (parts[3]) {
      var pi = parseInt(parts[3], 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }
    if (parts[4]) {
      var ri = parseInt(parts[4], 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }
    return payload;
  }

  function getCurrentQuestionById(qid) {
    var current = state.flatQuestions[state.currentIndex] && state.flatQuestions[state.currentIndex].question;
    if (current && String(current.id) === String(qid)) return current;

    for (var i = 0; i < state.flatQuestions.length; i++) {
      var q = state.flatQuestions[i].question;
      if (q && String(q.id) === String(qid)) return q;
    }
    return null;
  }

  function normalizePool(qid, leftMapping, ans) {
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[qid])) state.matchingPools[qid] = leftMapping.slice();

    var pool = state.matchingPools[qid];

    // used left
    var used = {};
    Object.keys(ans || {}).forEach(function(k) {
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) used[li] = true;
    });

    // remove used from pool
    var next = [];
    for (var i = 0; i < pool.length; i++) {
      var li2 = pool[i];
      if (!used[li2]) next.push(li2);
    }

    // add missing unused in leftMapping order
    for (var j = 0; j < leftMapping.length; j++) {
      var li3 = leftMapping[j];
      if (used[li3]) continue;
      if (next.indexOf(li3) === -1) next.push(li3);
    }

    state.matchingPools[qid] = next;
    return next;
  }

  function removeFromPool(pool, leftIdx, poolIndex) {
    if (!Array.isArray(pool)) return -1;

    if (typeof poolIndex === 'number' && poolIndex >= 0 && poolIndex < pool.length && pool[poolIndex] === leftIdx) {
      pool.splice(poolIndex, 1);
      return poolIndex;
    }

    var idx = pool.indexOf(leftIdx);
    if (idx >= 0) {
      pool.splice(idx, 1);
      return idx;
    }

    return -1;
  }

  function insertIntoPool(pool, leftIdx, index) {
    if (!Array.isArray(pool)) return;
    var i = (typeof index === 'number') ? index : pool.length;
    if (i < 0) i = 0;
    if (i > pool.length) i = pool.length;
    pool.splice(i, 0, leftIdx);
  }

  function leftForRight(ans, rightIdx) {
    var keys = Object.keys(ans || {});
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (ans[k] === rightIdx) return parseInt(k, 10);
    }
    return null;
  }

  function removeLeftFromAnswers(ans, leftIdx) {
    if (!ans || typeof ans !== 'object') return;
    if (ans.hasOwnProperty(leftIdx)) delete ans[leftIdx];
    if (ans.hasOwnProperty(String(leftIdx))) delete ans[String(leftIdx)];
  }

  // dragstart
  document.addEventListener('dragstart', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
      e.preventDefault();
      return;
    }

    var qid = card.getAttribute('data-qid');
    var left = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(left)) return;

    var from = card.getAttribute('data-from') || 'pool';
    var payload = { qid: qid, leftIdx: left, from: from };

    var piStr = card.getAttribute('data-pool-index');
    if (piStr !== null && piStr !== '') {
      var pi = parseInt(piStr, 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }

    var riStr = card.getAttribute('data-right');
    if (riStr !== null && riStr !== '') {
      var ri = parseInt(riStr, 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }

    try {
      e.dataTransfer.setData('application/json', JSON.stringify(payload));
      e.dataTransfer.setData(
        'text/plain',
        payload.qid + '|' + payload.leftIdx + '|' + payload.from + '|' +
        (payload.poolIndex !== undefined ? payload.poolIndex : '') + '|' +
        (payload.rightIdx !== undefined ? payload.rightIdx : '')
      );
      e.dataTransfer.effectAllowed = 'move';
    } catch (err) {}
  });

  // dragover
   document.addEventListener('dragover', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    setMatchOver(dropEl);
    try { e.dataTransfer.dropEffect = 'move'; } catch (err) {}
  });


    document.addEventListener('dragleave', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    // снимаем подсветку только если реально вышли из текущего drop
    if (__matchOverEl === dropEl && (!e.relatedTarget || !dropEl.contains(e.relatedTarget))) {
      clearMatchOver();
    }
  });


  // drop
  document.addEventListener('drop', function(e) {
    clearMatchOver();
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    dropEl.classList.remove('is-over');

    var payload = parsePayloadFromEvent(e);
    if (!payload || !payload.qid || Number.isNaN(payload.leftIdx)) return;

    var q = getCurrentQuestionById(payload.qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[payload.qid] && typeof state.answers[payload.qid] === 'object') ? state.answers[payload.qid] : {};

    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(payload.qid, leftMapping, ans);

    var poolSlotStr = dropEl.getAttribute('data-pool-slot');
    var targetRightStr = dropEl.getAttribute('data-right');
    var isPoolDrop = (poolSlotStr !== null && poolSlotStr !== '');

    if (isPoolDrop) {
      var targetSlot = parseInt(poolSlotStr, 10);
      if (Number.isNaN(targetSlot)) return;

      if (payload.from === 'pool') {
        var removedAt = removeFromPool(pool, payload.leftIdx, payload.poolIndex);
        if (removedAt >= 0 && removedAt < targetSlot) targetSlot = targetSlot - 1;
      } else {
        removeLeftFromAnswers(ans, payload.leftIdx);
      }

      insertIntoPool(pool, payload.leftIdx, targetSlot);

      state.answers[payload.qid] = ans;
      state.matchingPools[payload.qid] = pool;
      render();
      return;
    }

    var targetRight = parseInt(targetRightStr, 10);
    if (Number.isNaN(targetRight)) return;

    if (payload.from === 'pool') {
      removeFromPool(pool, payload.leftIdx, payload.poolIndex);
    } else {
      removeLeftFromAnswers(ans, payload.leftIdx);
    }

    var oldLeft = leftForRight(ans, targetRight);
    if (oldLeft !== null && !Number.isNaN(oldLeft)) {
      removeLeftFromAnswers(ans, oldLeft);

      if (payload.from === 'pool' && typeof payload.poolIndex === 'number') {
        insertIntoPool(pool, oldLeft, payload.poolIndex);
      } else {
        insertIntoPool(pool, oldLeft, pool.length);
      }
    }

    ans[payload.leftIdx] = targetRight;

    Object.keys(ans).forEach(function(k) {
      var li = parseInt(k, 10);
      if (li !== payload.leftIdx && ans[k] === targetRight) delete ans[k];
    });

    state.answers[payload.qid] = ans;
    state.matchingPools[payload.qid] = pool;
    render();
  });

  // dblclick matched -> return to pool
  document.addEventListener('dblclick', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    var from = card.getAttribute('data-from');
    if (from !== 'match') return;

    var qid = card.getAttribute('data-qid');
    var leftIdx = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(leftIdx)) return;

    var q = getCurrentQuestionById(qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[qid] && typeof state.answers[qid] === 'object') ? state.answers[qid] : {};
    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(qid, leftMapping, ans);

    removeLeftFromAnswers(ans, leftIdx);
    insertIntoPool(pool, leftIdx, pool.length);

    state.answers[qid] = ans;
    state.matchingPools[qid] = pool;
    render();
  });
}

var __rankClickBound = false;

function bindRankingClicksOnce() {
  if (__rankClickBound) return;
  __rankClickBound = true;

  document.addEventListener('click', function(e) {
    var el = e.target;

    // fallback если closest нет
    while (el && el !== document) {
      if (el.classList && el.classList.contains('rank-btn')) break;
      el = el.parentNode;
    }
    if (!el || el === document) return;

    if (el.disabled) return;

    var qId = el.getAttribute('data-qid');
    var pos = parseInt(el.getAttribute('data-pos'), 10);
    var dir = parseInt(el.getAttribute('data-dir'), 10);

    if (!qId || Number.isNaN(pos) || Number.isNaN(dir)) return;

    moveRank(qId, pos, dir);
  });
}

function initTimer() {
  if (TEST_DATA.timeLimitMinutes && TEST_DATA.timeLimitMinutes > 0) {
    state.remainingSeconds = TEST_DATA.timeLimitMinutes * 60;
    state.timerInterval = setInterval(updateTimer, 1000);
  }
}

function updateTimer() {
  if (state.submitted) {
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    return;
  }
  
  if (state.remainingSeconds === null || state.remainingSeconds <= 0) {
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    return;
  }
  
  state.remainingSeconds--;
  updateTimerDisplay();
  
  if (state.remainingSeconds <= 0 && !state.submitted) {
    state.timeExpired = true;
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    submit(true); // ✅ форсируем завершение даже без ответа на текущий вопрос
  }
}

function updateTimerDisplay() {
  var timerEl = document.getElementById('timer-display');
  if (timerEl && state.remainingSeconds !== null) {
    var mins = Math.floor(state.remainingSeconds / 60);
    var secs = state.remainingSeconds % 60;
    timerEl.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
    if (state.remainingSeconds <= 60) {
      timerEl.style.color = '#dc2626';
      timerEl.style.fontWeight = 'bold';
    }
  }
}

function formatTime(seconds) {
  var mins = Math.floor(seconds / 60);
  var secs = seconds % 60;
  return mins + ':' + (secs < 10 ? '0' : '') + secs;
}

function generateVariant() {
  state.variant = { sections: [] };
  state.flatQuestions = [];
  state.shuffleMappings = {}; // Store shuffle mappings for each question

  TEST_DATA.sections.forEach(function(section) {
    var questions = shuffle(section.questions.slice()).slice(0, section.drawCount);
    state.variant.sections.push({
      topicId: section.topicId,
      topicName: section.topicName,
      questionIds: questions.map(function(q) { return q.id; })
    });
    questions.forEach(function(q) {
      // Generate shuffle mappings for each question type
      if (q.type === 'single' || q.type === 'multiple') {
        var optCount = q.data.options ? q.data.options.length : 0;
        if (optCount > 0) {
          state.shuffleMappings[q.id] = createShuffleMapping(optCount);
        }
      } else if (q.type === 'matching') {
        var leftCount = q.data.left ? q.data.left.length : 0;
        var rightCount = q.data.right ? q.data.right.length : 0;
        if (leftCount > 0 && rightCount > 0) {
          state.shuffleMappings[q.id] = {
            left: createShuffleMapping(leftCount),
            right: createShuffleMapping(rightCount)
          };
        }
      } else if (q.type === 'ranking') {
        var itemCount = q.data.items ? q.data.items.length : 0;
        if (itemCount > 0) {
          state.shuffleMappings[q.id] = createShuffleMapping(itemCount);
          // Initialize ranking with shuffled order
          if (!state.answers[q.id]) {
            state.answers[q.id] = state.shuffleMappings[q.id].slice();
          }
        }
      }
      
      state.flatQuestions.push({
        question: q,
        topicId: section.topicId,
        topicName: section.topicName
      });
    });
  });
  state.flatQuestions = shuffle(state.flatQuestions);
}

function createShuffleMapping(length) {
  var indices = [];
  for (var i = 0; i < length; i++) {
    indices.push(i);
  }
  return shuffle(indices.slice());
}

function shuffle(arr) {
  for (var i = arr.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
  return arr;
}

function render() {
  if (state.phase === 'start') {
    renderStartPage();
    return;
  }
  
  var app = document.getElementById('app');
  var total = state.flatQuestions.length;
  var current = state.currentIndex;

  if (current >= total) {
    renderResults();
    return;
  }

  var qData = state.flatQuestions[current];
  var q = qData.question;
  var progress = ((current + 1) / total) * 100;

  var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">';
  html += '<h1 style="margin:0">' + escapeHtml(TEST_DATA.title) + '</h1>';
  if (state.remainingSeconds !== null) {
    var timerClass = state.remainingSeconds <= 60 ? 'style="color:#dc2626;font-weight:bold;font-size:18px;"' : 'style="color:#666;font-size:18px;"';
    html += '<div id="timer-display" ' + timerClass + '>' + formatTime(state.remainingSeconds) + '</div>';
  }
  html += '</div>';
  html += '<div class="progress-bar"><div class="progress-fill" style="width:' + progress + '%"></div></div>';
  html += '<div class="card">';
  html += '<div style="color:#666;margin-bottom:8px;">Вопрос ' + (current + 1) + ' из ' + total + ' | ' + escapeHtml(qData.topicName) + '</div>';
  html += '<div class="question-text">' + escapeHtml(q.prompt) + '</div>';
  html += renderQuestionMedia(q);
  html += renderQuestionInput(q);
  
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
    var answer = state.answers[q.id];
    var scoreRatio = checkAnswer(q, answer);
    var isCorrect = scoreRatio === 1;
    var statusColor = isCorrect ? '#16a34a' : '#dc2626';
    var statusText = isCorrect ? 'Правильно!' : (scoreRatio > 0 ? 'Частично правильно' : 'Неправильно');
    
    html += '<div style="margin-top:16px;padding:12px;border-radius:8px;background:' + (isCorrect ? '#dcfce7' : '#fee2e2') + ';border:1px solid ' + statusColor + ';">';
    html += '<div style="font-weight:600;color:' + statusColor + ';margin-bottom:4px;">' + statusText + '</div>';
    
    var feedbackText = null;
    if (q.feedbackMode === 'conditional') {
      feedbackText = isCorrect ? q.feedbackCorrect : q.feedbackIncorrect;
    } else {
      feedbackText = q.feedback;
    }
    
    if (feedbackText) {
      html += '<div style="color:#333;font-size:14px;">' + escapeHtml(feedbackText) + '</div>';
    }
    html += '</div>';
  }
  
  html += '</div>';
  html += '<div class="navigation" style="justify-content:flex-end">';
  
  if (TEST_DATA.showCorrectAnswers && !state.feedbackShown) {
    html += '<button class="btn" onclick="confirmAnswer()">Принять</button>';
  } else if (current < total - 1) {
    html += '<button class="btn" onclick="next()">Далее</button>';
  } else {
    html += '<button class="btn" onclick="submit()">Завершить тест</button>';
  }
  html += '</div>';

  app.innerHTML = html;
  syncMatchingHeights();
}

function renderStartPage() {
  var app = document.getElementById('app');
  var used = getAttemptsUsed();
  var hasLimit = !!TEST_DATA.maxAttempts;
  var left = hasLimit ? Math.max(0, TEST_DATA.maxAttempts - used) : null;
  
  var iconQuestions = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>';
  var iconPass = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>';
  var iconTime = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
  var iconAttempts = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>';
  
  var html = '<div class="start-page" style="max-width:600px;margin:40px auto;padding:0 18px;">';
  
  // Header card
  html += '<div class="card" style="padding:32px;text-align:center;margin-bottom:24px;background:hsl(var(--card));border:1px solid hsl(var(--border));">';
  html += '<h1 style="color:hsl(var(--foreground));margin:0;font-size:28px;font-weight:700;">' + escapeHtml(TEST_DATA.title) + '</h1>';
  if (TEST_DATA.description) {
    html += '<p style="color:hsl(var(--muted-foreground));margin-top:12px;margin-bottom:0;font-size:15px;">' + escapeHtml(TEST_DATA.description) + '</p>';
  }
  html += '</div>';
  
  // Info section
  html += '<div class="card" style="padding:24px;background:hsl(var(--card));border:1px solid hsl(var(--border));">';
  html += '<h2 style="margin:0 0 20px 0;font-size:18px;font-weight:700;color:hsl(var(--foreground));">Информация о тесте</h2>';
  
  html += '<div style="display:grid;gap:12px;">';
  
  // Количество вопросов
  html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
  html += '<div style="flex-shrink:0;color:#4f46e5;">' + iconQuestions + '</div>';
  html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Количество вопросов</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.totalQuestions + '</div></div>';
  html += '</div>';
  
  // Проходной балл
  html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
  html += '<div style="flex-shrink:0;color:#16a34a;">' + iconPass + '</div>';
  html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Проходной балл</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.passPercent + '%</div></div>';
  html += '</div>';
  
  // Ограничение времени
  if (TEST_DATA.timeLimitMinutes) {
    html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
    html += '<div style="flex-shrink:0;color:#f59e0b;">' + iconTime + '</div>';
    html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Ограничение времени</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.timeLimitMinutes + ' минут</div></div>';
    html += '</div>';
  }
  
  // Количество попыток
  if (TEST_DATA.maxAttempts) {
    html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
    html += '<div style="flex-shrink:0;color:#8b5cf6;">' + iconAttempts + '</div>';
    html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Попытки</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' 
    + (hasLimit ? ('осталось ' + left + ' из ' + TEST_DATA.maxAttempts) : 'без ограничений')
    + '</div></div>';
    html += '</div>';
  }
  
  html += '</div>';
  
  // Custom content
  if (TEST_DATA.startPageContent) {
    html += '<div style="margin-top:20px;padding:16px;background:hsl(var(--muted));border-radius:12px;border-left:4px solid hsl(var(--primary));border:1px solid hsl(var(--border));">';
    html += '<div style="color:hsl(var(--foreground));font-size:14px;line-height:1.6;">' + escapeHtml(TEST_DATA.startPageContent) + '</div>';
    html += '</div>';
  }
  
  // Start button
  var noAttempts = hasLimit && left <= 0;

  html += '<div style="margin-top:24px;text-align:center;">';
  html += '<button class="btn" '
    + (noAttempts ? 'disabled ' : '')
    + 'onclick="' + (noAttempts ? 'return false;' : 'startTest()') + '" '
    + 'style="padding:14px 40px;font-size:16px;font-weight:600;'
    + (noAttempts ? 'opacity:.55;cursor:not-allowed;' : '')
    + '">'
    + (noAttempts ? 'Попытки закончились' : 'Начать тестирование')
    + '</button>';
  html += '</div>';

  // закрываем карточку и обёртку страницы
  html += '</div></div>';
  
  app.innerHTML = html;
}

function startTest() {
  if (!hasAttemptsLeft()) {
    showToast('Попытки закончились', 'warn');
    return;
  }

  // фиксируем начало попытки
  var ok = registerAttemptStart();
  if (!ok) {
    showToast('Попытки закончились', 'warn');
    return;
  }

  state.phase = 'question';
  initTimer();
  render();
}


function showToast(message, kind) {
  var root = document.getElementById('toast-root');
  if (!root) return;

  var el = document.createElement('div');
  el.className = 'toast' + (kind ? (' ' + kind) : '');
  el.textContent = message;

  root.appendChild(el);

  setTimeout(function() {
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }, 2500);
}

function hasAnswer(q, answer) {
  if (!q) return true;

  if (q.type === 'single') return typeof answer === 'number';
  if (q.type === 'multiple') return Array.isArray(answer) && answer.length > 0;

  if (q.type === 'matching') {
    if (!answer || typeof answer !== 'object') return false;
    var need = (q.data && Array.isArray(q.data.left)) ? q.data.left.length : 0;
    var keys = Object.keys(answer);
    return keys.length === need && keys.every(function(k) {
      return typeof answer[k] === 'number';
    });
  }

  // ranking: порядок всегда есть (дефолтный тоже), считаем ответом
  if (q.type === 'ranking') return true;

  return answer !== undefined && answer !== null;
}

function requireAnswerOrToast() {
  var fq = state.flatQuestions[state.currentIndex];
  if (!fq) return true;

  var q = fq.question;
  var answer = state.answers[q.id];

  if (!hasAnswer(q, answer)) {
    showToast('Сначала ответьте на вопрос', 'warn');
    return false;
  }
  return true;
}

function confirmAnswer() {
  if (!requireAnswerOrToast()) return;
  state.feedbackShown = true;
  
  // Вместо render() - обновляем DOM точечно
  var fq = state.flatQuestions[state.currentIndex];
  var q = fq.question;
  var answer = state.answers[q.id];
  var scoreRatio = checkAnswer(q, answer);
  var isCorrect = scoreRatio === 1;
  
  // Блокируем варианты ответов (добавляем disabled и меняем курсор)
  lockAnswerOptions(q);
  
  // Показываем правильные/неправильные ответы
  if (TEST_DATA.showCorrectAnswers) {
    highlightCorrectAnswers(q, answer);
  }
  
  // Вставляем feedback после вопроса
  insertFeedback(q, isCorrect, scoreRatio);
  
  // Меняем кнопку "Принять" на "Далее"/"Завершить"
  updateNavigationButton();
}

function lockAnswerOptions(q) {
  // кликабельные .option
  var options = document.querySelectorAll('.option');
  options.forEach(function(opt) {
    opt.style.cursor = 'default';
    opt.onclick = null;
  });

  // все инпуты
  var inputs = document.querySelectorAll('input');
  inputs.forEach(function(input) {
    input.disabled = true;
  });

  // все селекты (matching)
  var selects = document.querySelectorAll('select');
  selects.forEach(function(sel) {
    sel.disabled = true;
  });

  // ranking buttons
  var rankButtons = document.querySelectorAll('.ranking-controls button');
  rankButtons.forEach(function(btn) {
    btn.disabled = true;
  });

    // ranking DnD
  var rankItems = document.querySelectorAll('.rank-draggable');
  rankItems.forEach(function(el) {
    el.setAttribute('draggable', 'false');
    el.style.cursor = 'default';
  });

}


function highlightCorrectAnswers(q, answer) {
  var correct = q.correct || {};
  
  if (q.type === 'single') {
    var correctIndex = correct.correctIndex;
    var options = document.querySelectorAll('.option');
    options.forEach(function(opt) {
      var dataIndex = opt.getAttribute('data-index');
      if (dataIndex !== null) {
        var idx = parseInt(dataIndex, 10);
        if (idx === correctIndex) {
          opt.classList.add('correct-answer');
        } else if (idx === answer) {
          opt.classList.add('incorrect-answer');
        }
      }
    });
  }
  
  if (q.type === 'multiple') {
    var correctSet = correct.correctIndices || [];
    var selectedSet = Array.isArray(answer) ? answer : [];
    var options = document.querySelectorAll('.option');
    options.forEach(function(opt) {
      var dataIndex = opt.getAttribute('data-index');
      if (dataIndex !== null) {
        var idx = parseInt(dataIndex, 10);
        var isCorrect = correctSet.indexOf(idx) !== -1;
        var isSelected = selectedSet.indexOf(idx) !== -1;
        
        if (isCorrect) {
          opt.classList.add('correct-answer');
        } else if (isSelected && !isCorrect) {
          opt.classList.add('incorrect-answer');
        }
      }
    });
  }
  
  // MATCHING
  if (q.type === 'matching') {
    highlightMatching(q, answer);
    return;
  }

  // RANKING
  if (q.type === 'ranking') {
    highlightRanking(q, answer);
    return;
  }
}

function highlightMatching(q, answer) {
  var pairs = (answer && typeof answer === 'object') ? answer : {};
  var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];

  // correct: rightIdx -> leftIdx
  var correctRightToLeft = {};
  correctPairsArr.forEach(function(p) { correctRightToLeft[p.right] = p.left; });

  // user: rightIdx -> leftIdx
  var userRightToLeft = {};
  Object.keys(pairs).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairs[k];
    if (typeof r === 'number') userRightToLeft[r] = l;
  });

  document.querySelectorAll('.matching-line[data-qid="' + q.id + '"]').forEach(function(line) {
    line.classList.remove('correct-answer', 'incorrect-answer');

    var rightAttr = line.getAttribute('data-right');
    if (rightAttr === null) return;

    var rightIdx = parseInt(rightAttr, 10);
    if (Number.isNaN(rightIdx)) return;

    if (!userRightToLeft.hasOwnProperty(rightIdx)) return;

    var userLeft = userRightToLeft[rightIdx];
    var correctLeft = correctRightToLeft[rightIdx];

    if (Number(userLeft) === Number(correctLeft)) {
      line.classList.add('correct-answer');
    } else {
      line.classList.add('incorrect-answer');
    }
  });
}

function highlightRanking(q, answer) {
  var correctOrder = Array.isArray((q.correct || {}).correctOrder) ? q.correct.correctOrder : [];
  if (!correctOrder.length) return;

  var rows = document.querySelectorAll('.ranking-board[data-qid="' + q.id + '"] .rank-item');
  if (!rows || !rows.length) return;

  rows.forEach(function(row, pos) {
    row.classList.remove('correct-answer', 'incorrect-answer');

    var itemIdx = parseInt(row.getAttribute('data-item'), 10);
    if (Number.isNaN(itemIdx)) return;

    var ok = (itemIdx === correctOrder[pos]);

    if (ok) {
      row.classList.add('correct-answer');
    } else {
      row.classList.add('incorrect-answer');
    }
  });
}


function insertFeedback(q, isCorrect, scoreRatio) {
  // Проверяем что feedback ещё не вставлен
  var existing = document.querySelector('.feedback-block');
  if (existing) return;
  
  var statusColor = isCorrect ? '#16a34a' : '#dc2626';
  var statusBg = isCorrect ? '#dcfce7' : '#fee2e2';
  var statusText = isCorrect ? 'Правильно!' : (scoreRatio > 0 ? 'Частично правильно' : 'Неправильно');
  
  var feedbackText = null;
  if (q.feedbackMode === 'conditional') {
    feedbackText = isCorrect ? q.feedbackCorrect : q.feedbackIncorrect;
  } else {
    feedbackText = q.feedback;
  }
  
  var html = '<div class="feedback-block" style="margin-top:16px;padding:12px;border-radius:8px;background:' + statusBg + ';border:1px solid ' + statusColor + ';">';
  html += '<div style="font-weight:600;color:' + statusColor + ';margin-bottom:4px;">' + statusText + '</div>';
  
  if (feedbackText) {
    html += '<div style="color:#333;font-size:14px;">' + escapeHtml(feedbackText) + '</div>';
  }
  html += '</div>';
  
  // Вставляем после .card
  var card = document.querySelector('.card');
  if (card) {
    card.insertAdjacentHTML('beforeend', html);
  }
}

function updateNavigationButton() {
  var navBtn = document.querySelector('.navigation .btn');
  if (!navBtn) return;
  
  var total = state.flatQuestions.length;
  var current = state.currentIndex;
  
  if (current < total - 1) {
    navBtn.textContent = 'Далее';
    navBtn.onclick = next;
  } else {
    navBtn.textContent = 'Завершить тест';
    navBtn.onclick = submit;
  }
}

function renderQuestionMedia(q) {
  if (!q.mediaUrl || !q.mediaType) return '';
  
  if (q.mediaType === 'image') {
    return '<div class="question-media"><img src="' + escapeHtml(q.mediaUrl) + '" alt="Question media" style="max-height:250px;max-width:100%;margin:16px auto;display:block;border-radius:8px;"></div>';
  }
  if (q.mediaType === 'audio') {
    return '<div class="question-media"><audio controls style="width:100%;margin:16px 0;"><source src="' + escapeHtml(q.mediaUrl) + '">Your browser does not support audio.</audio></div>';
  }
  if (q.mediaType === 'video') {
    return '<div class="question-media"><video controls style="max-height:250px;max-width:100%;margin:16px auto;display:block;border-radius:8px;"><source src="' + escapeHtml(q.mediaUrl) + '">Your browser does not support video.</video></div>';
  }
  return '';
}

function renderQuestionInput(q) {
  var answer = state.answers[q.id];
  var locked = TEST_DATA.showCorrectAnswers && state.feedbackShown;
  var correct = q.correct || {};
  var shuffleMapping = state.shuffleMappings[q.id];

  // SINGLE
  if (q.type === 'single') {
    var correctIndex = (typeof correct.correctIndex === 'number') ? correct.correctIndex : -1;
    var displayOrder = shuffleMapping || q.data.options.map(function(_, i) { return i; });
    var html = '';

    displayOrder.forEach(function(originalIndex) {
      var selected = answer === originalIndex ? 'selected' : '';
      var correctClass = '';
      if (locked) {
        if (originalIndex === correctIndex) correctClass = ' correct-answer';
        else if (answer === originalIndex && originalIndex !== correctIndex) correctClass = ' incorrect-answer';
      }
      var clickHandler = locked ? '' : 'onclick="selectSingle(\\'' + q.id + '\\',' + originalIndex + ')"';
      html += '<div class="option ' + selected + correctClass + '" data-index="' + originalIndex + '" ' + clickHandler + ' style="' + (locked ? 'cursor:default;' : '') + '">';
      html += '<input type="radio" name="q_' + q.id + '" ' + (answer === originalIndex ? 'checked' : '') + ' ' + (locked ? 'disabled' : '') + '>';
      html += escapeHtml(q.data.options[originalIndex]) + '</div>';
    });
    return html;
  }

  // MULTIPLE
  if (q.type === 'multiple') {
    var selectedArr = Array.isArray(answer) ? answer : [];
    var correctSet = Array.isArray(correct.correctIndices) ? correct.correctIndices : [];
    var displayOrder2 = shuffleMapping || q.data.options.map(function(_, i) { return i; });
    var html2 = '';

    displayOrder2.forEach(function(originalIndex) {
      var isSelected = selectedArr.indexOf(originalIndex) !== -1;
      var isCorrect = correctSet.indexOf(originalIndex) !== -1;
      var correctClass2 = '';
      if (locked) {
        if (isCorrect) correctClass2 = ' correct-answer';
        else if (isSelected && !isCorrect) correctClass2 = ' incorrect-answer';
      }
      var clickHandler2 = locked ? '' : 'onclick="toggleMultiple(\\'' + q.id + '\\',' + originalIndex + ')"';
      html2 += '<div class="option ' + (isSelected ? 'selected' : '') + correctClass2 + '" data-index="' + originalIndex + '" ' + clickHandler2 + ' style="' + (locked ? 'cursor:default;' : '') + '">';
      html2 += '<input type="checkbox" ' + (isSelected ? 'checked' : '') + ' ' + (locked ? 'disabled' : '') + '>';
      html2 += escapeHtml(q.data.options[originalIndex]) + '</div>';
    });
    return html2;
  }

  // MATCHING (Joined Drag & Drop like in UI)
  if (q.type === 'matching') {
    var pairs = (answer && typeof answer === 'object') ? answer : {};

    var mappingObj = shuffleMapping || {};
    var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
    var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

    // rightIdx -> leftIdx
    var rightToLeft = {};
    Object.keys(pairs).forEach(function(k){
      var l = parseInt(k, 10);
      var r = pairs[k];
      if (typeof r === 'number') rightToLeft[r] = l;
    });

    // normalize pool
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

    var pool = state.matchingPools[q.id];

    var usedLeft = {};
    Object.keys(pairs).forEach(function(k){
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) usedLeft[li] = true;
    });

    var nextPool = [];
    for (var pi = 0; pi < pool.length; pi++) {
      if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
    }

    leftMapping.forEach(function(li){
      if (usedLeft[li]) return;
      if (nextPool.indexOf(li) === -1) nextPool.push(li);
    });

    pool = nextPool;
    state.matchingPools[q.id] = pool;

    var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

    // pool раскладываем по НЕзаполненным строкам справа
    var poolSlot = 0;

    rightMapping.forEach(function(rightIdx) {
      var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
      var isJoined = (matchedLeft !== null);

      html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

      // LEFT
      if (isJoined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
              + escapeHtml(q.data.left[matchedLeft])
              + '</div>';
        html3 += '</div>';
      } else {
        var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

        if (poolLeft !== null && poolLeft !== undefined) {
          html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
          html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
                + escapeHtml(q.data.left[poolLeft])
                + '</div>';
          html3 += '</div>';
        } else {
          html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
                + '<span class="slot-placeholder">Перетащите вариант</span>'
                + '</div>';
        }

        poolSlot++;
      }

      html3 += '<div class="matching-gap"></div>';

      // RIGHT (drop target)
      html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
            + escapeHtml(q.data.right[rightIdx])
            + '</div>';

      html3 += '</div>';
    });

    html3 += '</div>';
    return html3;
  }

  // RANKING (Drag & Drop reorder)
  if (q.type === 'ranking') {
    var items = (q.data && Array.isArray(q.data.items)) ? q.data.items : [];

    // ответ храним как массив индексов исходных items: [2,0,1,...]
    var userOrder = Array.isArray(answer) ? answer.slice() : null;

    // если ответа ещё нет — ставим стартовый порядок 0..n-1
    if (!userOrder || userOrder.length !== items.length) {
      userOrder = items.map(function(_, i){ return i; });
      state.answers[q.id] = userOrder;
    }

    var html = '<div class="ranking-board" data-qid="' + escapeHtml(q.id) + '">';

    userOrder.forEach(function(itemIdx, pos){
      var text = (items[itemIdx] != null) ? String(items[itemIdx]) : ('#' + itemIdx);

      html += ''
        + '<div class="rank-item rank-draggable"'
        + ' draggable="true"'
        + ' data-qid="' + escapeHtml(q.id) + '"'
        + ' data-pos="' + pos + '"'
        + ' data-item="' + itemIdx + '">'
        +   '<span class="rank-grip">' + burgerSvgInline() + '</span>'
        +   '<span class="rank-text">' + escapeHtml(text) + '</span>'
        + '</div>';
    });

    html += '</div>';
    return html;
  }

  // маленький helper для “бургер-иконки”
  function burgerSvgInline(){
    return ''
      + '<svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">'
      + '<path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '<path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '<path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '</svg>';
  }


  // IMPORTANT: закрываем функцию правильно
  return '<div>Неизвестный тип вопроса</div>';
}

var __rankDndBound = false;
function bindRankingDnDOnce(){
  if (__rankDndBound) return;
  __rankDndBound = true;

  var dragPayload = null; // { qid, fromPos, itemIdx }

  function closestByClass(node, cls) {
    var el = node;
    while (el && el !== document) {
      if (el.classList && el.classList.contains(cls)) return el;
      el = el.parentNode;
    }
    return null;
  }

  // function clearOver(){
  //   document.querySelectorAll('.rank-item.is-over').forEach(function(n){
  //     n.classList.remove('is-over');
  //   });
  // }

  function getPayload(e){
    try {
      var raw = e.dataTransfer.getData('application/json');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (err) { return null; }
  }

  function moveInArray(arr, from, to){
    if (from === to) return arr;
    var copy = arr.slice();
    var item = copy.splice(from, 1)[0];
    copy.splice(to, 0, item);
    return copy;
  }

  document.addEventListener('dragstart', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (!el) return;

    // блокируем DnD после принятия
    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
      e.preventDefault();
      return;
    }

    var qid = el.getAttribute('data-qid');
    var fromPos = parseInt(el.getAttribute('data-pos'), 10);
    var itemIdx = parseInt(el.getAttribute('data-item'), 10);
    if (!qid || Number.isNaN(fromPos) || Number.isNaN(itemIdx)) return;

    dragPayload = { qid: qid, fromPos: fromPos, itemIdx: itemIdx };
    el.classList.add('dragging');

    try{
      e.dataTransfer.setData('application/json', JSON.stringify(dragPayload));
      e.dataTransfer.effectAllowed = 'move';
    }catch(err){}
  });

  document.addEventListener('dragend', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (el) el.classList.remove('dragging');
    dragPayload = null;
    clearMatchOver();
    // clearOver();
  });

  document.addEventListener('dragover', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    // clearOver();
    over.classList.add('is-over');

    try{ e.dataTransfer.dropEffect = 'move'; }catch(err){}
  });

  document.addEventListener('drop', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    over.classList.remove('is-over');

    var p = getPayload(e) || dragPayload;\
    if (!p) return;

    var qid = over.getAttribute('data-qid');
    if (!qid || qid !== p.qid) return;

    var toPos = parseInt(over.getAttribute('data-pos'), 10);
    if (Number.isNaN(toPos)) return;

    var current = state.answers[qid];
    if (!Array.isArray(current)) return;

    state.answers[qid] = moveInArray(current, p.fromPos, toPos);
    render();
  });
}

// function buildRankingBlockHtml(q, qId, order, locked, correctOrder) {
//   var html = '';

//   order.forEach(function(itemIdx, pos) {
//     var isCorrectPos = locked && itemIdx === correctOrder[pos];
//     var rowClass = locked ? (isCorrectPos ? 'correct-answer' : 'incorrect-answer') : '';

//     html += '<div class="ranking-item ' + rowClass + '" data-pos="' + pos + '" data-item="' + itemIdx + '">';
//     html +=   '<div class="ranking-controls">';
//     html +=     '<button type="button" class="rank-btn" data-qid="' + escapeHtml(qId) + '" data-pos="' + pos + '" data-dir="-1"' + (pos === 0 || locked ? ' disabled' : '') + '>▲</button>';
//     html +=     '<button type="button" class="rank-btn" data-qid="' + escapeHtml(qId) + '" data-pos="' + pos + '" data-dir="1"' + (pos === order.length - 1 || locked ? ' disabled' : '') + '>▼</button>';
//     html +=   '</div>';
//     html +=   '<span>' + (pos + 1) + '.</span>';
//     html +=   '<span>' + escapeHtml(q.data.items[itemIdx]) + '</span>';
//     html +=   '<span class="rank-hint-slot" style="margin-left:8px;font-size:12px;color:#16a34a;"></span>';
//     html += '</div>';
//   });

//   return html;
// }

function selectSingle(qId, idx) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;
  state.answers[qId] = idx;
  
  // Убрать selected у всех опций этого вопроса
  var allOptions = document.querySelectorAll('input[name="q_' + qId + '"]');
  allOptions.forEach(function(radio) {
    radio.checked = false;
    radio.parentElement.classList.remove('selected');
  });
  
  // Добавить selected к выбранному
  var selectedOption = document.querySelector('.option[data-index="' + idx + '"]');
  if (selectedOption) {
    selectedOption.classList.add('selected');
    var radio = selectedOption.querySelector('input[type="radio"]');
    if (radio) radio.checked = true;
  }
}

function toggleMultiple(qId, idx) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var current = Array.isArray(state.answers[qId]) ? state.answers[qId].slice() : [];
  var pos = current.indexOf(idx);

  if (pos === -1) current.push(idx);
  else current.splice(pos, 1);

  state.answers[qId] = current;

  // точечное обновление DOM через data-index
  var opt = document.querySelector('.option[data-index="' + idx + '"]');
  if (opt) {
    var cb = opt.querySelector('input[type="checkbox"]');
    var checked = current.indexOf(idx) !== -1;
    if (cb) cb.checked = checked;
    opt.classList.toggle('selected', checked);
  }
}

function setMatchWithMapping(qId, originalLeftIdx, displayRightVal) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var mappingObj = state.shuffleMappings[qId];
  var rightMapping = (mappingObj && mappingObj.right) ? mappingObj.right : null;

  var pairs = state.answers[qId] || {};

  if (displayRightVal === '' || displayRightVal === null || displayRightVal === undefined) {
    delete pairs[originalLeftIdx];
  } else {
    var displayRightIdx = parseInt(displayRightVal, 10);
    if (!Number.isNaN(displayRightIdx) && rightMapping && rightMapping[displayRightIdx] !== undefined) {
      pairs[originalLeftIdx] = rightMapping[displayRightIdx];
    }
  }

  state.answers[qId] = pairs;
}

function setMatch(qId, leftIdx, rightVal) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var pairs = state.answers[qId] || {};

  if (rightVal === '' || rightVal === null || rightVal === undefined) {
    delete pairs[leftIdx];
  } else {
    var n = parseInt(rightVal, 10);
    if (Number.isNaN(n)) delete pairs[leftIdx];
    else pairs[leftIdx] = n;
  }

  state.answers[qId] = pairs;
}

// function moveRank(qId, pos, dir) {
//   if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

//   var fq = state.flatQuestions.find(function(fq) { return fq.question.id === qId; });
//   if (!fq) return;

//   var q = fq.question;

//   var order = Array.isArray(state.answers[qId])
//     ? state.answers[qId].slice()
//     : q.data.items.map(function(_, i) { return i; });

//   var newPos = pos + dir;
//   if (newPos < 0 || newPos >= order.length) return;

//   var temp = order[pos];
//   order[pos] = order[newPos];
//   order[newPos] = temp;

//   state.answers[qId] = order;

//   // точечный перерендер только ranking-блока
//   var container = document.getElementById('ranking_' + qId);
//   if (container) {
//     var locked = false;
//     var correctOrder = Array.isArray((q.correct || {}).correctOrder) ? q.correct.correctOrder : order;
//     container.innerHTML = buildRankingBlockHtml(q, qId, order, locked, correctOrder);
//   }
// }


function next() {
  if (!requireAnswerOrToast()) return;

  if (state.currentIndex < state.flatQuestions.length - 1) {
    state.currentIndex++;
    state.feedbackShown = false;
    render();
  }
}


function submit(force) {
  if (state.submitted) return;

  // если не форс — требуем ответ на текущий вопрос
  if (!force) {
    if (!requireAnswerOrToast()) return;
  }

  state.submitted = true;

  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }

  state.currentIndex = state.flatQuestions.length;
  render();
}



function renderResults() {
  var results = calculateResults();
  var app = document.getElementById('app');

  var pct = Math.round(results.percent);
  var passed = !!results.passed;

  // ring
  var size = 140;
  var stroke = 14;
  var r = (size - stroke) / 2;
  var c = 2 * Math.PI * r;
  var offset = c - (pct / 100) * c;

  var html = '';
  html += '<div class="results-page">';

  // Top hero
  html +=   '<div class="results-hero">';
  html +=     '<div class="results-hero-icon ' + (passed ? 'is-pass' : 'is-fail') + '">';
  html +=       '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
  html +=         passed
    ? '<path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10"/><path d="M17 4v5a5 5 0 0 1-10 0V4"/><path d="M5 6h2"/><path d="M17 6h2"/>'
    : '<circle cx="12" cy="12" r="9"/><path d="M9 9l6 6"/><path d="M15 9l-6 6"/>';
  html +=       '</svg>';
  html +=     '</div>';
  html +=     '<div class="results-hero-title">' + (passed ? 'Поздравляем!' : 'Тест не пройден') + '</div>';
  html +=     '<div class="results-hero-sub">' + (passed ? 'Вы успешно прошли тест.' : 'Попробуйте ещё раз.') + '</div>';
  html +=   '</div>';

  // Main card
  html +=   '<div class="card results-main-card">';
  html +=     '<div class="results-main-title">' + escapeHtml(TEST_DATA.title || '') + '</div>';
  html +=     '<div class="results-main-sub">Результаты теста</div>';

  html +=     '<div class="results-ring">';
  html +=       '<svg viewBox="0 0 ' + size + ' ' + size + '">';
  html +=         '<circle cx="' + (size/2) + '" cy="' + (size/2) + '" r="' + r + '" class="ring-bg" stroke-width="' + stroke + '" fill="none"></circle>';
  html +=         '<circle cx="' + (size/2) + '" cy="' + (size/2) + '" r="' + r + '" class="ring-fg ' + (passed ? 'is-pass' : 'is-fail') + '" stroke-width="' + stroke + '" fill="none" stroke-linecap="round"';
  html +=           ' style="stroke-dasharray:' + c.toFixed(2) + ';stroke-dashoffset:' + offset.toFixed(2) + '"></circle>';
  html +=       '</svg>';
  html +=       '<div class="results-ring-center">';
  html +=         '<div class="results-ring-pct">' + pct + '%</div>';
  html +=         '<div class="results-ring-label">Баллы</div>';
  html +=       '</div>';
  html +=     '</div>';

  html +=     '<div class="results-stats">';
  html +=       '<div class="results-stat"><div class="v">' + results.totalQuestions + '</div><div class="l">Вопросов</div></div>';
  html +=       '<div class="results-stat"><div class="v">' + results.correct + '/' + results.totalQuestions + '</div><div class="l">Верно</div></div>';
  html +=       '<div class="results-stat"><div class="v">' + results.earnedPoints.toFixed(1) + '</div><div class="l">Баллов</div></div>';
  html +=       '<div class="results-pill ' + (passed ? 'is-pass' : 'is-fail') + '">' + (passed ? 'Пройден' : 'Не пройден') + '</div>';
  html +=     '</div>';
  html +=   '</div>';

  // Topics
  html +=   '<div class="results-section-title">Результаты по темам</div>';
  html +=   '<div class="results-topics-grid">';

  results.topicResults.forEach(function(tr) {
    var tpct = Math.round(tr.percent || 0);
    var tpass = (tr.passed === null) ? null : !!tr.passed;

    html += '<div class="card topic-card">';
    html +=   '<div class="topic-head">';
    html +=     '<div class="topic-left">';
    html +=       '<div class="topic-icon ' + (tpass ? 'is-pass' : 'is-fail') + '">';
    html +=         '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
    html +=           tpass ? '<path d="M20 6 9 17l-5-5"/>' : '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>';
    html +=         '</svg>';
    html +=       '</div>';
    html +=       '<div class="topic-name">' + escapeHtml(tr.topicName || '') + '</div>';
    html +=     '</div>';
    if (tpass !== null) {
      html +=   '<div class="results-pill ' + (tpass ? 'is-pass' : 'is-fail') + '">' + (tpass ? 'Пройден' : 'Нет') + '</div>';
    }
    html +=   '</div>';

    html +=   '<div class="topic-row">';
    html +=     '<div class="k">Вопросов</div>';
    html +=     '<div class="val">' + tr.total + ' / ' + tr.total + ' (' + tpct + '%)</div>';
    html +=   '</div>';

    html +=   '<div class="topic-row">';
    html +=     '<div class="k">Баллов</div>';
    html +=     '<div class="val">' + tr.earnedPoints.toFixed(1) + ' / ' + tr.possiblePoints.toFixed(1) + '</div>';
    html +=   '</div>';

    html +=   '<div class="topic-bar ' + (tpass ? 'is-pass' : 'is-fail') + '"><div style="width:' + Math.min(100, Math.max(0, tpct)) + '%"></div></div>';

    // если у темы есть passRule percent — покажем "Требуется: X%"
    var section = TEST_DATA.sections.find(function(s) { return s.topicId === tr.topicId; });
    if (section && section.topicPassRule && section.topicPassRule.type === 'percent') {
      html += '<div class="topic-required">Требуется: ' + section.topicPassRule.value + '%</div>';
    }

    html += '</div>';
  });

  html +=   '</div>';

  // ========== ДОБАВЬ ЭТОТ КОД ==========
  // Recommended Courses Section (только для непройденных тем)
  var failedTopics = results.topicResults.filter(function(tr) {
    return tr.passed === false && tr.recommendedCourses && tr.recommendedCourses.length > 0;
  });

  if (failedTopics.length > 0) {
    html += '<div class="results-section-title">Рекомендуемые курсы</div>';
    html += '<div style="margin-bottom:14px;color:hsl(var(--muted-foreground));font-size:14px;">';
    html += 'Изучите эти материалы для улучшения знаний по темам, которые требуют внимания.';
    html += '</div>';
    
    failedTopics.forEach(function(tr) {
      html += '<div class="card" style="padding:18px;margin-bottom:12px;">';
      html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">';
      html += '<div class="topic-icon is-fail">';
      html += '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
      html += '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>';
      html += '</svg>';
      html += '</div>';
      html += '<div class="topic-name">' + escapeHtml(tr.topicName) + '</div>';
      html += '</div>';
      
      tr.recommendedCourses.forEach(function(course) {
        html += '<div style="display:flex;align-items:center;gap:10px;padding:10px;background:hsl(var(--muted)/.5);border-radius:8px;margin-top:8px;">';
        html += '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="hsl(var(--primary))" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">';
        html += '<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>';
        html += '</svg>';
        html += '<a href="' + escapeHtml(course.url) + '" target="_blank" rel="noopener noreferrer" style="flex:1;color:hsl(var(--primary));text-decoration:none;font-weight:500;font-size:14px;">';
        html += escapeHtml(course.title);
        html += '</a>';
        html += '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="hsl(var(--muted-foreground))" stroke-width="2">';
        html += '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" x2="21" y1="14" y2="3"/>';
        html += '</svg>';
        html += '</div>';
      });
      
      html += '</div>';
    });
  }

  // Actions
  var canFinish = results.passed || results.percent >= 100;
  var noAttempts = TEST_DATA.maxAttempts && !hasAttemptsLeft();
  var timeAndNoAttempts = state.timeExpired && noAttempts;

  html += '<div class="results-actions">';

  if (canFinish || noAttempts || timeAndNoAttempts) {
    html += '<button class="btn" onclick="finishAndClose()">Завершить тест</button>';
  } else {
    html += '<button class="btn btn-outline" onclick="restart()">Пройти заново</button>';
  }

  html += '</div>';

  app.innerHTML = html;
  //finishScorm(results);
}


function restart() {
  if (!hasAttemptsLeft()) {
    showToast('Попытки закончились', 'warn');
    return;
  }
  state.phase = 'start';
  state.currentIndex = 0;
  state.answers = {};
  state.variant = null;
  state.flatQuestions = [];
  state.submitted = false;
  state.feedbackShown = false;
  state.timeExpired = false;

  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }
  state.remainingSeconds = null;

  generateVariant();
  render();
}

var scormFinished = false;

function finishAndClose() {
  if (scormFinished) return;
  scormFinished = true;

  var results = calculateResults();

  var attemptsExhausted = !!TEST_DATA.maxAttempts && !hasAttemptsLeft();
  var realPassed = !!results.passed;

  // по умолчанию — честно
  var passedForLms = realPassed;

  // если время вышло — считаем провалом (и не закрываем "читом")
  if (state.timeExpired) {
    passedForLms = false;
  }

  // ✅ ХАК ДЛЯ WebSoft:
  // если попытки кончились и тест НЕ пройден — закрываем курс, иначе он висит "в процессе"
  if (attemptsExhausted && !realPassed && !state.timeExpired) {
    passedForLms = true;

    // маркер в данные, чтобы было видно, что фактически не сдал
    try {
      SCORM.setValue('cmi.comments_from_learner', 'ATTEMPTS_EXHAUSTED: FAILED (forced close)');
    } catch (e) {}
  }

  finishScorm(results, passedForLms);

  try { SCORM.commit(); } catch (e) {}
  try { SCORM.terminate(); } catch (e) {}
  try { window.close(); } catch (e) {}
}


window.finishAndClose = finishAndClose;


function calculateResults() {
  var totalEarnedPoints = 0;  // Sum of earned points (weighted by question points)
  var totalPossiblePoints = 0; // Total possible points
  var totalFullyCorrect = 0; // Fully correct count
  var totalQuestions = 0;
  var topicData = {};

  state.flatQuestions.forEach(function(fq) {
    var q = fq.question;
    var answer = state.answers[q.id];
    var scoreRatio = checkAnswer(q, answer);
    var qPoints = q.points || 1;

    totalPossiblePoints += qPoints;
    totalEarnedPoints += qPoints * scoreRatio;
    totalQuestions++;
    if (scoreRatio === 1) totalFullyCorrect++;

    if (!topicData[fq.topicId]) {
      var section = TEST_DATA.sections.find(function(s) { return s.topicId === fq.topicId; });
      topicData[fq.topicId] = {
        topicId: fq.topicId,
        topicName: fq.topicName,
        correct: 0,
        earnedPoints: 0,
        possiblePoints: 0,
        total: 0,
        passRule: section.topicPassRule,
        topicFeedback: section.topicFeedback || null,
        recommendedCourses: section.recommendedCourses || []
      };
    }
    topicData[fq.topicId].total++;
    topicData[fq.topicId].possiblePoints += qPoints;
    topicData[fq.topicId].earnedPoints += qPoints * scoreRatio;
    if (scoreRatio === 1) topicData[fq.topicId].correct++;
  });

  // Use point-based percentage for overall score (matches backend)
  var overallPercent = totalPossiblePoints > 0 ? (totalEarnedPoints / totalPossiblePoints) * 100 : 0;
  // Pass rule evaluation: percent type uses point-based percentage, count type uses fully correct count
  var overallPassed = checkPassRuleWithPartial(TEST_DATA.overallPassRule, overallPercent, totalFullyCorrect);

  var topicResults = [];
  var allTopicsPassed = true;

  Object.keys(topicData).forEach(function(tid) {
    var td = topicData[tid];
    // Use point-based percentage (matches backend)
    td.percent = td.possiblePoints > 0 ? (td.earnedPoints / td.possiblePoints) * 100 : 0;
    if (td.passRule) {
      td.passed = checkPassRuleWithPartial(td.passRule, td.percent, td.correct);
      if (!td.passed) allTopicsPassed = false;
    } else {
      td.passed = null;
    }
    topicResults.push(td);
  });

  var passed = overallPassed && allTopicsPassed;

  return {
    correct: totalFullyCorrect,
    totalQuestions: totalQuestions,
    earnedPoints: totalEarnedPoints,
    possiblePoints: totalPossiblePoints,
    percent: overallPercent,
    passed: passed,
    topicResults: topicResults
  };
}

// Returns a score between 0 and 1 (supports partial credit)
function checkAnswer(q, answer) {
  if (answer === undefined || answer === null) return 0;

  var correct = q.correct || {};

  // SINGLE
  if (q.type === 'single') {
    return answer === correct.correctIndex ? 1 : 0;
  }

  // MULTIPLE — строгое совпадение множеств
  if (q.type === 'multiple') {
    var correctIndices = Array.isArray(correct.correctIndices) ? correct.correctIndices.slice() : [];
    var user = Array.isArray(answer) ? answer.slice() : [];

    if (correctIndices.length === 0) return 0;
    if (user.length !== correctIndices.length) return 0;

    correctIndices.sort();
    user.sort();

    for (var i = 0; i < correctIndices.length; i++) {
      if (correctIndices[i] !== user[i]) return 0;
    }
    return 1;
  }

  // MATCHING — все пары должны совпасть
  if (q.type === 'matching') {
    var pairs = (answer && typeof answer === 'object') ? answer : {};
    var correctPairs = Array.isArray(correct.pairs) ? correct.pairs : [];

    if (Object.keys(pairs).length !== correctPairs.length) return 0;

    for (var i = 0; i < correctPairs.length; i++) {
      var p = correctPairs[i];
      if (pairs[p.left] !== p.right) return 0;
    }
    return 1;
  }

  // RANKING — порядок должен совпасть полностью
  if (q.type === 'ranking') {
    var order = Array.isArray(answer) ? answer : [];
    var correctOrder = Array.isArray(correct.correctOrder) ? correct.correctOrder : [];

    if (order.length !== correctOrder.length) return 0;

    for (var i = 0; i < order.length; i++) {
      if (order[i] !== correctOrder[i]) return 0;
    }
    return 1;
  }

  return 0;
}

function checkPassRule(rule, correct, total) {
  if (!rule) return true;
  if (rule.type === 'percent') {
    return (correct / total) * 100 >= rule.value;
  }
  return correct >= rule.value;
}

// Pass rule check that properly handles partial credit
// For percent rules, uses the already-calculated percent (from earned/possible)
// For count rules, uses the fully correct count
function checkPassRuleWithPartial(rule, percent, fullyCorrectCount) {
  if (!rule) return true;
  if (rule.type === 'percent') {
    return percent >= rule.value;
  }
  return fullyCorrectCount >= rule.value;
}

function finishScorm(results, passedForLms) {
  var objectives = results.topicResults.map(function(tr) {
    return {
      id: 'topic_' + tr.topicId,
      score: Math.round(tr.percent),
      status: tr.passed === null ? 'unknown' : (tr.passed ? 'passed' : 'failed')
    };
  });

  var interactions = [];

  function to1(x) { return typeof x === 'number' ? x + 1 : x; }

  function mapScormType(q) {
    if (q.type === 'single') return 'choice';
    if (q.type === 'multiple') return 'choice';
    if (q.type === 'matching') return 'matching';
    if (q.type === 'ranking') return 'sequencing';
    return 'other';
  }

  function formatResponse(q, ans) {
    if (ans == null) return '';

    if (q.type === 'single') return String(to1(ans));
    if (q.type === 'multiple') return ans.map(to1).join(',');
    if (q.type === 'ranking') return ans.map(to1).join(',');
    if (q.type === 'matching') {
      return Object.keys(ans)
        .sort((a,b)=>a-b)
        .map(k => to1(+k) + '-' + to1(ans[k]))
        .join(',');
    }
    return '';
  }

  function getCorrectAnswerFor(q) {
    var c = q.correct || {};
    if (q.type === 'single') return c.correctIndex;
    if (q.type === 'multiple') return c.correctIndices || [];
    if (q.type === 'ranking') return c.correctOrder || [];
    if (q.type === 'matching') {
      var m = {};
      (c.pairs || []).forEach(p => m[p.left] = p.right);
      return m;
    }
    return null;
  }

  state.flatQuestions.forEach(function(fq) {
    var q = fq.question;
    var ans = state.answers[q.id];
    var fullCorrect = checkAnswer(q, ans) === 1;

    interactions.push({
      id: 'q_' + q.id,
      type: mapScormType(q),
      result: fullCorrect ? 'correct' : 'incorrect',
      response: formatResponse(q, ans),
      correct: formatResponse(q, getCorrectAnswerFor(q)),
      description: q.prompt || ''
    });
  });

  var percentScore = Math.round(results.percent);
  SCORM.finish(percentScore, 100, passedForLms, objectives, interactions);
}

function escapeHtml(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}
    function readSuspendObj() {
  try {
    var raw = SCORM.getValue('cmi.suspend_data') || '';
    if (!raw) return {};
    return JSON.parse(raw);
  } catch (e) {
    return {};
  }
}

function writeSuspendObj(obj) {
  try {
    var raw = JSON.stringify(obj || {});
    // SCORM 2004 suspend_data обычно до ~64KB, нам хватит
    SCORM.setValue('cmi.suspend_data', raw);
    SCORM.commit();
  } catch (e) {}
}

function getAttemptsUsed() {
  var s = readSuspendObj();
  return typeof s.attemptsUsed === 'number' ? s.attemptsUsed : 0;
}

function setAttemptsUsed(n) {
  var s = readSuspendObj();
  s.attemptsUsed = n;
  s.lastUpdated = new Date().toISOString();
  writeSuspendObj(s);
}

function hasAttemptsLeft() {
  if (!TEST_DATA.maxAttempts) return true; // если лимит не задан — не ограничиваем
  return getAttemptsUsed() < TEST_DATA.maxAttempts;
}

// Увеличиваем попытку 1 раз на запуск теста
function registerAttemptStart() {
  if (!TEST_DATA.maxAttempts) return true;

  var used = getAttemptsUsed();
  if (used >= TEST_DATA.maxAttempts) return false;

  setAttemptsUsed(used + 1);
  return true;
}

`;
}


function loadAppThemeTokensCss(): { light: string | null; dark: string | null } {
  // Пытаемся прочитать реальные токены темы из client/src/index.css
  // (они у тебя в :root и .dark) 
  const candidates = [
    path.resolve(process.cwd(), "client/src/index.css"),
    path.resolve(process.cwd(), "client/index.css"),
  ];

  for (const p of candidates) {
    try {
      const css = fs.readFileSync(p, "utf8");
      const light = extractBlock(css, ":root");
      const dark = extractBlock(css, ".dark");
      if (light) return { light, dark };
    } catch {
      // ignore
    }
  }

  // Фолбэк (чтобы экспорт не падал, если исходников нет на сервере)
  return {
    light: `:root { --background: 0 0% 100%; --foreground: 0 0% 9%; --border: 0 0% 89%; --card: 0 0% 98%; --primary: 217 91% 42%; --primary-foreground: 0 0% 98%; --secondary: 217 12% 90%; --muted: 217 10% 92%; --muted-foreground: 0 0% 35%; --accent: 217 8% 93%; --destructive: 0 84% 38%; --font-sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; --radius: .5rem; --chart-3: 160 75% 32%; }`,
    dark: `.dark { --background: 0 0% 9%; --foreground: 0 0% 98%; --border: 0 0% 18%; --card: 0 0% 11%; --primary: 217 91% 35%; --primary-foreground: 0 0% 98%; --secondary: 217 12% 19%; --muted: 217 10% 17%; --muted-foreground: 0 0% 68%; --accent: 217 8% 17%; --destructive: 0 84% 32%; --chart-3: 160 75% 42%; }`,
  };
}

function extractBlock(css: string, selector: string): string | null {
  const re = new RegExp(`\\${selector}\\s*\\{[\\s\\S]*?\\}`, "m");
  const m = css.match(re);
  return m ? m[0] : null;
}

function extractBodyFromBlock(block: string): string {
  const m = block.match(/\{([\s\S]*?)\}/m);
  return m ? `{${m[1]}}` : "{}";
}